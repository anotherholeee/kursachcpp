# Описание алгоритмов FindRoutes и CalculateArrivalTimes

## Алгоритм по шагам для функции findRoutes

### Шаг 1. Начало.

**Входные данные:**

- `const std::string& stopA` – начальная остановка, от которой требуется найти маршруты;

- `const std::string& stopB` – конечная остановка, до которой требуется найти маршруты.

**Выходные данные:**

- `List<std::shared_ptr<Route>>` – список найденных маршрутов, которые проходят через обе остановки в правильном направлении.

### Шаг 2. Создать результирующий список.

Инициализировать пустой контейнер `List<std::shared_ptr<Route>> foundRoutes` для хранения найденных маршрутов.

### Шаг 3. Получить список всех маршрутов системы.

Вызвать метод `system->getRoutes()` и сохранить результат в константную ссылку `const auto& routes`.

### Шаг 4. Начать цикл по всем маршрутам системы.

Организовать цикл `for (const auto& route : routes)`, где `route` – текущий маршрут из списка всех маршрутов.

### Шаг 5. Проверить условия для добавления маршрута.

Выполнить проверку всех трёх условий одновременно с помощью логического оператора `&&`:

- Вызвать метод `route->containsStop(stopA)` для проверки наличия начальной остановки в маршруте;

- Вызвать метод `route->containsStop(stopB)` для проверки наличия конечной остановки в маршруте;

- Вызвать метод `route->isStopBefore(stopA, stopB)` для проверки, что остановка `stopA` находится раньше остановки `stopB` в последовательности остановок маршрута.

Если хотя бы одно из условий возвращает `false`, перейти к Шагу 7 (следующая итерация цикла). Если все условия возвращают `true`, перейти к Шагу 6.

### Шаг 6. Добавить маршрут в результирующий список.

Если все условия выполнены (маршрут содержит начальную остановку, содержит конечную остановку, начальная остановка находится перед конечной), вызвать метод `foundRoutes.push_back(route)` для добавления маршрута в список результатов.

### Шаг 7. Завершить итерацию цикла.

Продолжить итерацию до конца списка маршрутов `routes`. Если обработаны не все маршруты, вернуться к Шагу 4 для обработки следующего маршрута.

### Шаг 8. Вернуть результат.

После завершения цикла вернуть контейнер `foundRoutes`, содержащий все маршруты, которые проходят через обе указанные остановки в правильном направлении.

### Шаг 9. Конец алгоритма.

---

## Алгоритм по шагам для функции calculateArrivalTimes

### Шаг 1. Начало.

**Входные данные:**

- `int tripId` – идентификатор рейса, для которого требуется рассчитать время прибытия;

- `double averageSpeed` – средняя скорость движения транспортного средства в километрах в час.

**Выходные данные:**

- Функция не возвращает значение (тип `void`), но обновляет расписание рейса, устанавливая время прибытия на каждую остановку маршрута.

### Шаг 2. Проверить корректность средней скорости.

Проверить условие `averageSpeed <= 0`. Если условие истинно, сгенерировать исключение `InputException` с сообщением "Средняя скорость должна быть положительной" и завершить выполнение функции. Если условие ложно, продолжить выполнение.

### Шаг 3. Получить список всех рейсов системы.

Вызвать метод `system->getTrips()` и сохранить результат в константную ссылку `const auto& trips`.

### Шаг 4. Найти рейс с указанным идентификатором.

Использовать алгоритм `std::find_if` для поиска рейса в списке `trips`, у которого идентификатор совпадает с параметром `tripId`. Сохранить результат поиска в итератор `auto tripIt`. Лямбда-функция для поиска: `[tripId](const auto& t) { return t->getTripId() == tripId; }`.

### Шаг 5. Проверить наличие рейса в системе.

Проверить условие `tripIt == trips.end()`. Если условие истинно (рейс не найден), сгенерировать исключение `ContainerException` с сообщением "Рейс с ID " + std::to_string(tripId) + " не найден" и завершить выполнение функции. Если условие ложно, продолжить выполнение.

### Шаг 6. Получить объект рейса.

Получить объект рейса из итератора: `auto trip = *tripIt`.

### Шаг 7. Получить список остановок маршрута рейса.

Вызвать метод `trip->getRoute()->getAllStops()` и сохранить результат в константную ссылку `const auto& stopsList`.

### Шаг 8. Проверить наличие остановок в маршруте.

Проверить условие `stopsList.empty()`. Если условие истинно (маршрут не содержит остановок), сгенерировать исключение `ContainerException` с сообщением "Маршрут не содержит остановок" и завершить выполнение функции. Если условие ложно, продолжить выполнение.

### Шаг 9. Получить время отправления рейса.

Вызвать метод `trip->getStartTime()` и сохранить результат в переменную `Time currentTime`.

### Шаг 10. Установить время прибытия на начальную остановку.

Установить время прибытия на первую остановку маршрута (с индексом 0), вызвав метод `trip->setArrivalTime(stopsList[0], currentTime)`. Время прибытия на начальную остановку равно времени отправления рейса.

### Шаг 11. Инициализировать константы расчета.

Установить константы для расчета:

- `const double distanceBetweenStops = 1.5` – расстояние между остановками в километрах;

- `const int stopTime = 1` – время стоянки на остановке в минутах.

### Шаг 12. Начать цикл по остальным остановкам маршрута.

Организовать цикл `for (size_t i = 1; i < stopsList.size(); ++i)`, где `i` – индекс текущей остановки (начинается с 1, так как первая остановка уже обработана).

### Шаг 13. Рассчитать время движения до текущей остановки.

Вычислить время движения в минутах по формуле:

- `double travelTimeMinutes = (distanceBetweenStops / averageSpeed) * 60`

Формула: время движения = (расстояние / скорость) × 60 (для перевода часов в минуты).

### Шаг 14. Рассчитать время прибытия на текущую остановку.

Вычислить время прибытия, добавив время движения к текущему времени и округлив до ближайшего целого числа минут:

- `Time arrivalTime = currentTime + static_cast<int>(travelTimeMinutes + 0.5)`

Использование `static_cast<int>(travelTimeMinutes + 0.5)` обеспечивает округление до ближайшего целого числа минут.

### Шаг 15. Записать время прибытия для текущей остановки.

Вызвать метод `trip->setArrivalTime(stopsList[i], arrivalTime)` для сохранения времени прибытия на остановку с индексом `i`.

### Шаг 16. Рассчитать время отправления со следующей остановки.

Вычислить время отправления, добавив время стоянки к времени прибытия:

- `currentTime = arrivalTime + stopTime`

Формула: время отправления = время прибытия + время стоянки.

**Примечание:** В текущей реализации время отправления не сохраняется отдельно, а используется как `currentTime` для расчета следующей остановки.

### Шаг 17. Завершить итерацию цикла по остановкам.

Продолжить итерацию до конца списка остановок `stopsList`. Если обработаны не все остановки (`i < stopsList.size() - 1`), вернуться к Шагу 12 для обработки следующей остановки. Если обработана последняя остановка (`i == stopsList.size() - 1`), перейти к Шагу 18.

### Шаг 18. Завершить расчет времени прибытия.

Все времена прибытия рассчитаны и сохранены в расписании рейса через метод `setArrivalTime()`.

**Примечание:** В текущей реализации метод `calculateArrivalTimes` не вызывает явный метод сохранения расписания, так как времена сохраняются непосредственно в объекте `Trip` через метод `setArrivalTime()`.

### Шаг 19. Конец алгоритма.

---

## Изменения в алгоритмах по сравнению с предыдущей версией

### Изменения в алгоритме findRoutes:

1. **Тип возвращаемого значения:**
   - **Было:** `std::vector<std::shared_ptr<Route>>`
   - **Стало:** `List<std::shared_ptr<Route>>`
   - **Причина:** В актуальном коде используется пользовательский контейнер `List` вместо стандартного `std::vector`.

2. **Структура проверок условий:**
   - **Было:** Три отдельных шага (Шаг 5, Шаг 6, Шаг 7) для последовательной проверки каждого условия с переходами к следующей итерации при неудаче.
   - **Стало:** Один объединённый шаг (Шаг 5), где все три условия проверяются одновременно с помощью логического оператора `&&`.
   - **Причина:** В актуальном коде все три проверки объединены в одно условие `if`: `if (route->containsStop(stopA) && route->containsStop(stopB) && route->isStopBefore(stopA, stopB))`.

3. **Нумерация шагов:**
   - Из-за объединения проверок общее количество шагов уменьшилось с 11 до 9.

### Изменения в алгоритме calculateArrivalTimes:

1. **Детализация поиска рейса (Шаг 4):**
   - **Добавлено:** Уточнение о лямбда-функции, используемой в `std::find_if`: `[tripId](const auto& t) { return t->getTripId() == tripId; }`.
   - **Причина:** Более точное описание соответствует актуальной реализации кода.

2. **Формат сообщения об ошибке (Шаг 5):**
   - **Было:** "Рейс с ID [tripId] не найден" (с плейсхолдером)
   - **Стало:** "Рейс с ID " + std::to_string(tripId) + " не найден" (с явным преобразованием числа в строку)
   - **Причина:** Соответствует актуальному коду, где используется `std::to_string(tripId)` для формирования сообщения об ошибке.

### Общие изменения:

- Алгоритмы приведены в соответствие с актуальной реализацией в файле `algorithm.cpp` (строки 163-176 для `findRoutes` и строки 129-161 для `calculateArrivalTimes`).
- Все описания шагов точно отражают структуру и логику выполнения кода.
