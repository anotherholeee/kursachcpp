# Рекомендации по использованию контейнеров

## Самописный Deque

В проекте реализован самописный контейнер `Deque<T>`, который заменяет `std::vector` в следующих местах:

1. **TransportSystem**:
   - `Deque<std::shared_ptr<Route>> routes` - маршруты
   - `Deque<std::shared_ptr<Trip>> trips` - рейсы
   - `Deque<std::shared_ptr<Vehicle>> vehicles` - транспортные средства
   - `Deque<std::shared_ptr<Driver>> drivers` - водители
   - `Deque<Stop> stops` - остановки

2. **JourneyPlanner**:
   - `Deque<Journey>` - результаты поиска маршрутов
   - `Deque<std::shared_ptr<Trip>>` - пути в поиске маршрутов

## Где лучше использовать std::unordered_map вместо Deque

### Проблема: Линейный поиск O(n)

В текущей реализации методы поиска по ключу выполняют линейный поиск по Deque:

```cpp
// transport_system.cpp
std::shared_ptr<Route> TransportSystem::getRouteByNumber(int number) {
    for (const auto& route : routes) {  // O(n) поиск
        if (route->getNumber() == number) {
            return route;
        }
    }
    return nullptr;
}

std::shared_ptr<Trip> TransportSystem::getTripById(int id) {
    for (const auto& trip : trips) {  // O(n) поиск
        if (trip->getTripId() == id) {
            return trip;
        }
    }
    return nullptr;
}

std::shared_ptr<Vehicle> TransportSystem::getVehicleByLicensePlate(const std::string& licensePlate) {
    for (const auto& vehicle : vehicles) {  // O(n) поиск
        if (vehicle->getLicensePlate() == licensePlate) {
            return vehicle;
        }
    }
    return nullptr;
}
```

### Решение: Использовать std::unordered_map для быстрого поиска

**Рекомендуемое место для улучшения:** `TransportSystem` класс

**Предлагаемая структура:**

```cpp
class TransportSystem {
private:
    // Основные контейнеры (Deque для последовательного доступа)
    Deque<std::shared_ptr<Route>> routes;
    Deque<std::shared_ptr<Trip>> trips;
    Deque<std::shared_ptr<Vehicle>> vehicles;
    Deque<std::shared_ptr<Driver>> drivers;
    Deque<Stop> stops;
    
    // Индексы для быстрого поиска (std::unordered_map для O(1) поиска)
    std::unordered_map<int, std::shared_ptr<Route>> routesByNumber;      // номер -> маршрут
    std::unordered_map<int, std::shared_ptr<Trip>> tripsById;            // ID -> рейс
    std::unordered_map<std::string, std::shared_ptr<Vehicle>> vehiclesByPlate;  // номер -> транспорт
    std::unordered_map<int, std::shared_ptr<Driver>> driversById;        // ID -> водитель (если добавить ID)
    
    // Существующие индексы
    std::unordered_map<int, std::string> stopIdToName;
    std::unordered_map<std::string, std::string> adminCredentials;
};
```

**Преимущества:**

1. **Производительность**: O(1) поиск вместо O(n)
2. **Масштабируемость**: При большом количестве элементов (1000+) разница становится критичной
3. **Частые операции**: Методы `getTripById`, `getRouteByNumber` вызываются часто при поиске маршрутов

**Обновленные методы:**

```cpp
std::shared_ptr<Route> TransportSystem::getRouteByNumber(int number) {
    auto it = routesByNumber.find(number);  // O(1)
    return (it != routesByNumber.end()) ? it->second : nullptr;
}

std::shared_ptr<Trip> TransportSystem::getTripById(int id) {
    auto it = tripsById.find(id);  // O(1)
    return (it != tripsById.end()) ? it->second : nullptr;
}

std::shared_ptr<Vehicle> TransportSystem::getVehicleByLicensePlate(const std::string& licensePlate) {
    auto it = vehiclesByPlate.find(licensePlate);  // O(1)
    return (it != vehiclesByPlate.end()) ? it->second : nullptr;
}
```

**Синхронизация индексов:**

При добавлении/удалении элементов нужно обновлять оба контейнера:

```cpp
void TransportSystem::addRouteDirect(std::shared_ptr<Route> route) {
    routes.push_back(route);
    routesByNumber[route->getNumber()] = route;  // Обновляем индекс
}

void TransportSystem::removeRouteDirect(int routeNumber) {
    auto it = std::find_if(routes.begin(), routes.end(),
                          [routeNumber](const auto& r) { 
                              return r->getNumber() == routeNumber; 
                          });
    if (it != routes.end()) {
        routesByNumber.erase(routeNumber);  // Удаляем из индекса
        routes.erase(it);
    }
}
```

## Итоговые рекомендации

1. **Deque** - отлично подходит для:
   - Последовательного доступа
   - Добавления/удаления с обеих сторон
   - Итерации по всем элементам
   - Сохранения порядка элементов

2. **std::unordered_map** - лучше использовать для:
   - Поиска по уникальному ключу (ID, номер)
   - Частых операций поиска
   - Когда нужна производительность O(1)

3. **Комбинированный подход** (рекомендуется):
   - Deque для хранения и последовательного доступа
   - std::unordered_map как индекс для быстрого поиска
   - Синхронизация обоих контейнеров при изменениях

